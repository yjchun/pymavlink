#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a python implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''
from __future__ import print_function

from builtins import range

import os
import textwrap
from . import mavtemplate

t = mavtemplate.MAVTemplate()


def generate_preamble(outf, msgs, basename, args, xml):
    print("Generating preamble")
    t.write(outf, """
'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
'''
from micropython import const


class Protocol:
    WIRE_PROTOCOL_VERSION = '${WIRE_PROTOCOL_VERSION}'
    DIALECT = '${DIALECT}'

    PROTOCOL_MARKER_V1 = 0xFE
    PROTOCOL_MARKER_V2 = 0xFD
    HEADER_LEN_V1 = 6
    HEADER_LEN_V2 = 10

    MAVLINK_SIGNATURE_BLOCK_LEN = 13

    MAVLINK_IFLAG_SIGNED = 0x01


class MessageDef:
    def __init__(self, msgid, fieldnames, fieldtypes, orders, lengths, array_lengths, crc_extra, format_str) -> None:
        self.msgid = msgid
        # (unordered) fieldnames
        self.fieldnames = fieldnames
        # (unordered) field types
        self.fieldtypes = fieldtypes
        self.orders = orders
        self.lengths = lengths
        self.array_lengths = array_lengths
        self.crc_extra = crc_extra
        self.format_str = format_str

""", {'FILELIST': ",".join(args),
      'PROTOCOL_MARKER': xml.protocol_marker,
      'DIALECT': os.path.splitext(os.path.basename(basename))[0],
      'crc_extra': xml.crc_extra,
      'WIRE_PROTOCOL_VERSION': xml.wire_protocol_version})


def generate_enums(outf, enums):
    print("Generating enums")
    outf.write('''
# enums
class MavEnum:
''')
    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="                        # ")
    for e in enums:
        outf.write("\n    # %s\n" % e.name)
        for entry in e.entry:
            outf.write("    %s = const(%u) # %s\n" % (entry.name, entry.value, wrapper.fill(entry.description)))


def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("\n# message IDs\n")
    outf.write('''
class MsgId:
''')
    outf.write("    MAVLINK_MSG_ID_BAD_DATA = const(-1)\n")
    for m in msgs:
        outf.write("    %s = const(%u)\n" % (m.name.upper(), m.id))


def byname_hash_from_field_attribute(m, attribute):
    strings = []
    for field in m.fields:
        value = getattr(field, attribute, None)
        if value is None or value == "":
            continue
        if attribute == 'units':
            # hack; remove the square brackets further up
            if value[0] == "[":
                value = value[1:-1]
        strings.append('"%s": "%s"' % (field.name, value))
    return ", ".join(strings)

def generate_classes(outf, msgs):
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper(initial_indent="        ", subsequent_indent="        ")

    outf.write("""
msgdefs = {
""")
    for m in msgs:

        classname = "MAVLink_%s_message" % m.name.lower()
        fieldname_str = ", ".join(["'%s'" % s for s in m.fieldnames])
        ordered_fieldname_str = ", ".join(["'%s'" % s for s in m.ordered_fieldnames])
        fielddisplays_str = byname_hash_from_field_attribute(m, "display")
        fieldenums_str = byname_hash_from_field_attribute(m, "enum")
        fieldunits_str = byname_hash_from_field_attribute(m, "units")

        #fieldtypes_str = ", ".join(["'%s'" % s for s in m.fieldtypes])
        fieldtypes_str = "".join(["%s" % fmtmap[s] for s in m.fieldtypes])
        if m.instance_field is not None:
            instance_field = "'%s'" % m.instance_field
            instance_offset = m.field_offsets[m.instance_field]
        else:
            instance_field = "None"
            instance_offset = -1
        outf.write(f"""    MsgId.{m.name.upper()}: MessageDef(MsgId.{m.name.upper()},
        ({fieldname_str}),
        '{fieldtypes_str}',
        {tuple(m.order_map)},
        {tuple(m.len_map)},
        {tuple(m.array_len_map)},
        {m.crc_extra}, '{m.fmtstr}'),
""")

    outf.write("""}

""")

fmtmap = {
        'float': 'f',
        'double': 'd',
        'char': 'c', # micropython does not support 'c'
        'int8_t': 'b',
        'uint8_t': 'B',
        'uint8_t_mavlink_version': 'v',
        'int16_t': 'h',
        'uint16_t': 'H',
        'int32_t': 'i',
        'uint32_t': 'I',
        'int64_t': 'q',
        'uint64_t': 'Q',
        }
def native_mavfmt(field):
    '''work out the struct format for a type (in a form expected by mavnative)'''
    return fmtmap[field.type]


def mavfmt(field):
    '''work out the struct format for a type'''
    map = {
        'float': 'f',
        'double': 'd',
        'char': 'B', # micropython does not support 'c'
        'int8_t': 'b',
        'uint8_t': 'B',
        'uint8_t_mavlink_version': 'B',
        'int16_t': 'h',
        'uint16_t': 'H',
        'int32_t': 'i',
        'uint32_t': 'I',
        'int64_t': 'q',
        'uint64_t': 'Q',
        }

    if field.array_length:
        if field.type == 'char':
            return str(field.array_length)+'s'
        return str(field.array_length)+map[field.type]
    return map[field.type]


def mavdefault(field):
    '''returns default value for field (as string) for mavlink2 extensions'''
    if field.type == 'char':
        default_value = "''"
    else:
        default_value = "0"
    if field.array_length == 0:
        return default_value
    return "[" + ",".join([default_value] * field.array_length) + "]"


def generate(basename, xml):
    '''generate complete python implementation'''
    if basename.endswith('.py'):
        filename = basename
    else:
        filename = basename + '.py'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        m.fielddefaults = []
        if xml[0].little_endian:
            m.fmtstr = '<'
        else:
            m.fmtstr = '>'
        m.native_fmtstr = m.fmtstr
        m.instance_field = None
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
            m.fielddefaults.append(mavdefault(f))
            m.native_fmtstr += native_mavfmt(f)
            if f.instance:
                m.instance_field = f.name
        m.order_map = [0] * len(m.fieldnames)
        m.len_map = [0] * len(m.fieldnames)
        m.array_len_map = [0] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])
            m.array_len_map[i] = m.ordered_fields[i].array_length
        for i in range(0, len(m.fieldnames)):
            n = m.order_map[i]
            m.len_map[n] = m.fieldlengths[i]

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, basename, filelist, xml[0])
    generate_enums(outf, enums)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs)
    outf.close()
    print("Generated %s OK" % filename)
